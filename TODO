# TODO

- sequential escrow, how does it impact offer, arb, etc? trade and escrow probly ok

- update contract documentation
- create list of every page/function to be added to site
- create list of every user path
- deploy
  - create users
  - test every user path
- front page should be a filterable list of offers perhaps?
- profile update?
- admin panel
- page to show log of events perhaps
- F2F wizard

- write up blog post on uvp.

- walk through all contracts and understand them step by step

### The RAI: Remittance Acceleration Interface

> This connects 2 offers to permit a taker to move fiat currency in country X to fiat currency in country Y using crypto as a transport layer. So, this would connect an offer that sells fiat for crypto in country X with an offer to buy fiat in country Y with the crypto from the first offer.

- question: What asset are you starting with? What asset are you ending with?
- use algorithm to display paths: Pathfinding Algorithm: Implement an algorithm that identifies the most efficient path(s) for converting the initial asset into the final asset. Efficiency could be measured in terms of cost, speed, or a combination of factors defined by the user.
  - take a source currency and target currency and return a list of intermediate trades necessary for conversion
- breakdown each step
- per offer: show fees, exchange rates (sources)
- total: show total fees, both from offers and from network, KYC requirements
- amount in, amount out
- risk level / confidence score (based on reputations?)
- Estimated execution time
- Allow users to drag and drop offers to create a chain.
- Enable users to filter offers based on criteria such as fiat currency, crypto currency, and trade amount. (pro user mode?)
- Saved Transactions: Allow users to save chained transactions as templates for future use.

### Events

- An off-chain service, such as a Node.js application or a cloud function, listens for events emitted from the contracts.
- Store contract-emitted events, including notifications, off-chain.
- store trade history data in a storage provider such as PlanetScale or Arweave with cryptographic proofs/sigs/hashes so the integrity can be verified.
  - Looks like I can emit them as events and then store them elsewhere.
  - web3.eth.getLogs
  - consider GraphQL
- API for retrieving events, including trade history
